#include <iostream>
#include <cassert>
#include <cstdlib>

/*
 * Даны неотрицательные целые числа n, k и массив целых чисел из [0..10^9] размера n.
 * Требуется найти k-ю порядковую статистику, т.е. напечатать число, которое бы стояло
 * на позиции с индексом k (0..n-1) в отсортированном массиве Напишите нерекурсивный алгоритм.
 * Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
 * Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
 * Описание для случая прохода от начала массива к концу:
 *     - Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива
 *     - Во время работы Partition в начале массиве содержатся элементы, не большие опорного.
 *       Затем располагаются элементы, сторого большие опорного. В конце массива лежат
 *       нерассмотренные элементы. Последним элементом лежит опорный.
 *     - Итератор (индекс) i указывает на начало группы элементов, строго больших опорного.
 *     - Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
 *     - Шаг алгоритма. Рассмативается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
 *       Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
 *     - В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
 * 
 * Реализуйте стратегию выбора опорного элемента "случайный элемент".
 * Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.
 * 
 * |  in                    |  out                      |
 * |------------------------+---------------------------|
 * |  10 4                  |  5                        |
 * |  1 2 3 4 5 6 7 8 9 10  |                           |
 * |------------------------+---------------------------|
 * |  10 0                  |  1                        |
 * |  3 6 5 7 2 9 8 10 4 1  |                           |
 * |------------------------+---------------------------|
 * |  10 9                  |  1                        |
 * |  0 0 0 0 0 0 0 0 0 1   |                           |
 */

// Функция ввода и валидации данных.
void input(size_t* arr, size_t n);

// Нерекурсивная функция поиска k-ой порядковой статистики за линейное время.
size_t KstatDC(size_t* arr, size_t size, size_t k);

size_t partition(size_t* arr, size_t size);

int main(int argc, char* argv[])
{
    int n, k;
    std::cin >> n >> k;
    assert(n > 0);
    if(n == 0) return 0;
    assert(k >= 0);

    size_t* arr = new size_t[n];
    input(arr, (size_t)n);
    size_t statistics = KstatDC(arr, (size_t)n, (size_t)k);
    assert(statistics < (size_t)n);

    std::cout << statistics << std::endl;
    delete[] arr;

    return 0;

}

// Функция ввода и валидации данных.
void input(size_t* arr, size_t n)
{
    for(size_t i = 0; i < n; i++) {
        long long tmp;
        std::cin >> tmp;
        assert(tmp >= 0 && tmp <= 1000000000);
        arr[i] = (size_t)tmp;
    }
}

// Нерекурсивная функция поиска k-ой порядковой статистики за линейное время.
size_t KstatDC(size_t* arr, size_t size, size_t k)
{
    size_t pivot = partition(arr, size);

    if(pivot == k) {
        return arr[pivot];
    }

    if(pivot > k) {
        return KstatDC(arr, pivot, k);
    }

    return KstatDC(arr + pivot + 1, size - pivot - 1, k - pivot - 1);
}

size_t partition(size_t* arr, size_t size){

    size_t pivot = (size_t)rand() % size;
    std::swap(arr[pivot], arr[0]);

    size_t j = size - 1;
    size_t i = j;
    while(i > 0) {
        if(arr[i] < arr[0]) {
            i--;
        } else {
            std::swap(arr[i], arr[j]);
            i--;
            j--;
        }
    }

    std::swap(arr[j], arr[0]);
    return j;
}
